# 用户中途中断调用时的积分处理

**问题**：如果用户在模型还没有返回答案的时候就中断调用了，积分还会扣除吗？

**答案**：取决于**中断发生的时机**。

---

## 关键理解

### new-api 的流程

```
1. 用户请求到达
    ↓
2. PreConsumeQuota（预扣费）
    ├─ 检查积分
    ├─ 预先扣除估计消耗
    └─ relayInfo.FinalPreConsumedQuota 记录预扣额度
    ↓
3. 调用上游模型（如 OpenAI）
    ├─ 发送请求到 upstream
    ├─ 等待响应...
    └─ 获取 usage (promptTokens, completionTokens)
    ↓
4. postConsumeQuota（后扣费）
    ├─ 计算实际消耗 quota
    ├─ 对比预扣和实际
    └─ 调整用户余额（返还或额外扣费）
    ↓
5. RecordConsumeLog（记录日志）
    └─ 只在这里才发送 webhook 到 LetAiCode
```

---

## 中断场景分析

### 场景 1：用户在 PreConsumeQuota 后、调用模型前中断

```
请求 → PreConsumeQuota（预扣费 100）
    ↓
✅ 用户积分已扣除：1000 - 100 = 900
    ↓
用户断开连接 ❌
    ↓
❌ 不会调用上游模型
    ↓
❌ 不会进入 postConsumeQuota
    ↓
❌ 不会进入 RecordConsumeLog
    ↓
❌ 不会发送 webhook 到 LetAiCode
    ↓
结果：new-api 中积分已扣除，但 LetAiCode 那边不知道
      （需要等 5 分钟轮询才能同步）
```

### 场景 2：用户在调用模型时中断（最常见）

```
请求 → PreConsumeQuota（预扣费 100）
    ↓
✅ 用户积分已扣除：1000 - 100 = 900
    ↓
调用 OpenAI API... 用户中断连接 ❌
    ↓
HTTP 连接断开，但：
├─ OpenAI 可能还在处理请求
├─ OpenAI 可能已经返回了部分结果
└─ new-api 没有收到完整响应
    ↓
error 处理（如网络超时、连接断开）
    ↓
ReturnPreConsumedQuota（返还预扣费）
    ├─ 返还给 new-api：100
    ├─ new-api 积分恢复：900 + 100 = 1000
    ↓
❌ 不会进入 postConsumeQuota
    ↓
❌ 不会进入 RecordConsumeLog
    ↓
❌ 不会发送 webhook 到 LetAiCode
    ↓
结果：积分最终被返还，用户没被扣费
      但 LetAiCode 可能还有短时间的 new-api 侧预扣余额
```

### 场景 3：用户在模型返回答案后中断（响应发回时中断）

```
请求 → PreConsumeQuota（预扣费 100）
    ↓
✅ 用户积分已扣除：1000 - 100 = 900
    ↓
调用 OpenAI API... 成功返回！
    ├─ promptTokens: 50
    ├─ completionTokens: 30
    └─ 实际消耗 quota: 70
    ↓
✅ 进入 postConsumeQuota
    ├─ 计算实际消耗：70
    ├─ 对比预扣：100 > 70
    ├─ 需要返还：100 - 70 = 30
    ├─ UPDATE users SET quota = ... （返还给 new-api 用户）
    ↓
✅ 进入 RecordConsumeLog
    ├─ 记录使用：70 quota
    ├─ 发送 webhook 到 LetAiCode（异步）
    │  └─ eventId: xxx, creditCost: 70
    ↓
✅ 即使此时用户中断连接
    ├─ webhook 已在后台发送
    ├─ LetAiCode 会处理这个 webhook
    ├─ 扣除用户的积分：70
    └─ 最终一致性得到保证
    ↓
结果：用户被正确扣费 70，没有多扣也没有少扣 ✅
```

---

## 详细的返还逻辑

从 relay.go 的代码可以看到：

```go
// relay/compatible_handler.go
defer func() {
    // 只在 relay 出错 AND 预扣费了金额 时，才返还
    if newAPIError != nil && relayInfo.FinalPreConsumedQuota != 0 {
        service.ReturnPreConsumedQuota(c, relayInfo)
    }
}()

// 然后尝试调用各个 helper
err := relayHandler(c, info)

// 如果 err == nil，说明成功，进行 postConsumeQuota
if err == nil {
    postConsumeQuota(c, info, usage, "")
    // → 这里才记录日志
    // → 这里才发送 webhook
    return nil
}

// 如果 err != nil，defer 中会自动返还
```

**关键点**：`ReturnPreConsumedQuota` 和 `RecordConsumeLog` **互斥** 的

---

## 对于新的实时检查方案的影响

当我们实现了**实时查询 LetAiCode 积分**的方案后，这个中断问题会变得**更加明显**：

### 当前问题（5分钟轮询）

```
用户积分实际：0
    ↓
new-api 缓存的积分：100（5分钟前同步的）
    ↓
用户调用 API：通过了预检
    ↓
模型被调用了
    ↓
webhook 发送回 LetAiCode
    ↓
LetAiCode：检查积分不足，webhook 失败
```

### 新方案的改进

```
用户积分实际：0
    ↓
PreConsumeQuota 实时查询 LetAiCode：0
    ↓
拒绝调用（403）
    ↓
❌ 模型不会被调用
    ↓
❌ 积分不会被预扣（因为根本没通过检查）
```

**所以实时检查会从源头就防止用户透支！**

---

## 中断场景的完整处理表

| 中断时机 | 预扣费状态 | 模型调用 | 返还 | Webhook | LetAiCode 积分 | 说明 |
|---------|----------|--------|------|---------|--------------|------|
| PreConsume 前 | ❌ 无 | ❌ 否 | ❌ 无 | ❌ 否 | 无变化 | 最佳情况 |
| PreConsume 后 | ✅ 有 | ❌ 否 | ✅ 有 | ❌ 否 | 短时不同步 |  |
| 调用中 | ✅ 有 | ⚠️ 中止 | ✅ 有 | ❌ 否 | 短时不同步 |  |
| 模型返回后 | ✅ 有 | ✅ 是 | 🔄 调整 | ✅ 是 | ✅ 正确扣费 | 最终一致 |

---

## 需要补充的处理

为了完善中断处理，我们应该添加：

### 1. 未完成请求的追踪

```go
// 在 middleware 中记录请求开始
c.Set("request_start_time", time.Now())

// 在 defer 中检查是否实际完成
defer func() {
    if c.Writer.Written() == false && newAPIError != nil {
        logger.LogWarn(c, "request not fully written before error")
        // 发送追踪信息
    }
}()
```

### 2. webhook 失败时的补偿

当 webhook 发送失败时，当前有两个机制：
- ✅ 新-api 会重试 3 次（指数退避）
- ✅ LetAiCode 有 5 分钟轮询作为备份

### 3. 中断连接时的预扣费监控

```
监控预扣费未返还的情况：
├─ 某个 token 的预扣费很多
├─ 但 webhook 从未来过
└─ 发送告警给管理员
```

---

## 建议的改进方案

### 短期（可选）

1. **添加心跳检测**：在流式响应中定期发送心跳，检测连接是否真的中断
2. **记录预扣费超时**：如果预扣费超过 30 分钟还未返还，自动返还并记录日志

### 中期

1. **WebSocket 连接检测**：对于长连接，实现更好的中断检测
2. **预扣费时间限制**：设置预扣费的有效期（如 1 小时后自动返还）

### 长期

1. **积分预留账户**：为每个用户维护一个预留账户，真正扣费时才从主账户转移
2. **事务性设计**：将整个流程设计为原子性事务

---

## 对 LetAiCode webhook 的影响

### 当前 webhook 实现中

```typescript
// webhook.service.ts
async handleWebhookEvent(payload: WebhookPayload) {
  // 1. 检查幂等性
  const existingLog = await prisma.webhookLog.findUnique({
    where: { eventId }
  });

  if (existingLog?.status === 'processed') {
    // 2. 如果已处理，直接返回成功
    return { success: true, message: 'Event already processed' };
  }

  // 3. 处理 webhook
  await this.handleUsageEvent(data);

  // 4. 记录成功
  await prisma.webhookLog.upsert({...});
}
```

**问题**：如果用户中断连接，但 webhook 最终还是送达了，会怎样？

**答案**：仍然会被正确处理（幂等性保证）

```
场景：用户中断 → 预扣费返还 → webhook 迟到送达
    ↓
LetAiCode 接收 webhook
    ├─ 根据 eventId 检查是否已处理
    ├─ 如果已处理 → 返回成功（幂等）
    ├─ 如果未处理 → 处理 webhook
    │  ├─ 创建 UsageRecord
    │  ├─ 创建 CreditTransaction
    │  └─ 扣费
    ↓
最终一致性得到保证 ✅
```

---

## 总结

### 现状

1. **中断早期**（PreConsume 后）：用户积分被预扣，模型未调用
   - new-api：积分已扣
   - LetAiCode：不知道（等 5 分钟轮询）

2. **中断中期**（模型调用中）：预扣费被返还，但 LetAiCode 不知道
   - new-api：积分已返还
   - LetAiCode：短时间内不知道（等轮询）

3. **中断后期**（模型返回后）：完全正常处理，最终一致性保证

### 改进后

1. **实时检查方案**会从源头防止用户透支
2. **幂等性设计**确保即使 webhook 迟到也不会重复扣费
3. **降级机制**确保系统高可用

### 需要监控的

- [ ] 预扣费返还失败的情况
- [ ] webhook 发送失败率
- [ ] 长时间未返还的预扣费
