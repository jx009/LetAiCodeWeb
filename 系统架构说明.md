# 系统架构澄清：new-api 中的 Quota 到底是什么？

## 🤔 你的困惑

> loveyouai 是无限额度的，那 PreConsumeQuota 检查的是什么？LetAiCode 的积分啊，但 loveyouai 没有 LetAiCode 的积分啊！

这是个**非常好的问题**！让我彻底解释这个架构。

## 📊 系统架构真相

### 关键发现：new-api 的 User 表中也有 Quota 字段！

```sql
-- new-api 数据库中的 users 表
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR,
    quota INT,              ← 这里有 Quota！
    used_quota INT,
    ...
);
```

### new-api 用户的 Quota 作用

new-api 中的 Quota 有**多个含义**：

```
new-api 用户的 Quota 用途：
├─ 1️⃣ 【系统级别】new-api 本身对用户的额度限制
│  ├─ 这是 new-api 的管理员为了控制成本设置的
│  ├─ 例如：防止某个 token 被滥用导致消耗过大
│  └─ 对标 LetAiCode 的积分系统
│
└─ 2️⃣ 【同步对接】与 LetAiCode 积分系统的桥接
   ├─ 当 LetAiCode 充值时，需要同步到 new-api
   ├─ LetAiCode: 积分 1000 → 同步 → new-api: quota 1000
   ├─ new-api 使用这个 quota 进行额度控制
   └─ 保证两个系统的积分一致
```

## 🔄 完整的数据同步流程

### 现状架构（5分钟轮询）

```
LetAiCode 用户充值
    ↓
LetAiCode 积分增加：1000
    ↓
【每 5 分钟一次】LetAiCode 主动同步到 new-api
    ↓
new-api 用户的 quota 也增加：1000
    ↓
用户用 new-api token 调用 API
    ├─ new-api 检查自己的 quota：1000 > 0 ✅
    ├─ 执行调用
    └─ 扣除 new-api quota
```

### 新架构（Webhook 实时同步）

```
LetAiCode 用户充值
    ↓
LetAiCode 积分增加：1000
    ├─ 同步到 new-api
    └─ new-api quota 也增加：1000
    ↓
用户用 new-api token 调用 API
    ├─ new-api 检查自己的 quota：1000 > 0 ✅
    ├─ 执行调用，实际消耗 80
    └─ 发送 Webhook 到 LetAiCode
        ├─ eventId: xxx
        ├─ 实际消耗: 80
        └─ LetAiCode 记录使用，扣除积分 80
            ↓
【同步】LetAiCode 积分现在是 920
            ↓
下次调用时，new-api 也从 920 开始计算
```

## 🗂️ 三个不同的"积分/额度"概念

### 1️⃣ LetAiCode 的"积分"（Credit）

```sql
-- LetAiCode 数据库
SELECT * FROM credit_transactions WHERE userId = '123';

-- 结构
{
  userId: "uuid-of-letaicode-user",
  type: "DEDUCT",
  amount: -80,
  balance: 920,  ← 当前积分余额
  ref: "usage-record-id",
  desc: "API 调用扣费（gpt-4，150 tokens）"
}
```

**特点**：
- 存储在 LetAiCode 数据库
- 面向用户（用户充值、查看消费）
- 粒度细：记录每一笔交易
- 用户看得到

### 2️⃣ new-api 的"Quota"（额度）

```sql
-- new-api 数据库
SELECT id, username, quota FROM users WHERE id = 42;

Result:
id    | username        | quota
------|-----------------|-------
42    | letaicode_sync  | 920

-- 这个 quota 是从 LetAiCode 同步来的
```

**特点**：
- 存储在 new-api 数据库
- 是 LetAiCode 积分的"镜像"
- 用于控制 API 调用权限
- 系统内部使用

### 3️⃣ Token 的"RemainQuota"（令牌剩余额度）

```sql
-- new-api 数据库
SELECT id, name, remain_quota FROM tokens WHERE id = 123;

Result:
id  | name           | remain_quota
----|----------------|---------------
123 | my-gpt4-token  | 500

-- 这个是针对单个 token 的额度限制
-- 例如：创建 token 时设置"最多用 500 额度"
```

**特点**：
- 针对单个 token 的限制
- 可以比用户 quota 更严格
- 例如：给合作伙伴的 token 设置上限

## 🔗 三个积分系统的关系

```
┌─────────────────────────────────────────────────────────────────┐
│                    LetAiCode 用户积分体系                        │
│                                                                 │
│  用户 A                          用户 B                         │
│  └─ 积分: 1000                   └─ 积分: 500                  │
│      │                               │                          │
│      └─ API Key 1                    └─ API Key 2              │
│          │                               │                      │
│          └─ remoteKeyId: 10             └─ remoteKeyId: 20    │
└─────────────────────────────────────────────────────────────────┘
                            ↓
                    【Webhook 同步】
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                     new-api 用户额度体系                         │
│                                                                 │
│  用户 (letaicode_sync)                                          │
│  └─ quota: 1500 (1000 + 500 合并)                              │
│      │                                                          │
│      ├─ Token 10                       ├─ Token 20             │
│      │  └─ remain_quota: (共享)        │  └─ remain_quota: (共享)
│      │  └─ unlimited_quota: false      │  └─ unlimited_quota: true
│      │                                 │                       │
│      └─ 与用户 A 的 API Key 关联      └─ 与用户 B 的 API Key 关联
│
│  调用流程：
│  ① 用户 A 使用 Token 10 调用 API
│  ② new-api 检查：Token 10 对应 User (letaicode_sync)
│  ③ 检查 User.quota: 1500 > 0? ✅
│  ④ 检查 Token.remain_quota: ? ✅
│  ⑤ 执行调用
│  ⑥ 发送 Webhook: Token 10 消耗了 80 积分
│  ⑦ LetAiCode 接收并扣除用户 A 的积分: 1000 → 920
└─────────────────────────────────────────────────────────────────┘
```

## 🎯 所以 PreConsumeQuota 检查的是什么？

### 答案：检查的是 new-api 中 User.quota 字段

```go
// loveyouai/service/pre_consume_quota.go

func PreConsumeQuota(c *gin.Context, preConsumedQuota int, relayInfo *relaycommon.RelayInfo) {
    // 这里的 relayInfo.UserId 是什么？
    // 答案：是 new-api 中的用户 ID，而不是 LetAiCode 用户 ID！

    userQuota, err := model.GetUserQuota(relayInfo.UserId, false)
    //                                 ↑
    //                          这是 new-api 的用户 ID

    // 获取的 quota 值从哪来？
    // 答案：从 new-api 数据库的 users 表的 quota 字段

    if userQuota <= 0 {
        return "用户额度不足"  // 拒绝调用
    }

    if userQuota - preConsumedQuota < 0 {
        return "预扣费额度失败"  // 拒绝调用
    }
}
```

### 核心理解

```
new-api 中有一个"特殊用户"代表所有 LetAiCode 用户：

new-api users 表
├─ id: 1
├─ username: "admin"
├─ quota: -1 (无限)
└─ ...

└─ id: 0
   ├─ username: "letaicode_sync"
   ├─ quota: 合并的所有 LetAiCode 用户积分
   └─ ...

当 LetAiCode 用户调用 API 时，new-api 实际上是用的这个共享用户
所以 PreConsumeQuota 检查的是这个共享用户的 quota
```

## 📈 完整的数据流动

### 场景：LetAiCode 用户充值

```
1️⃣ LetAiCode 前端
   └─ 用户点击"充值"

2️⃣ LetAiCode 后端
   └─ 积分交易：
      {
        userId: "abc123",
        type: "RECHARGE",
        amount: 1000,
        balance: 2000
      }

3️⃣ LetAiCode 可能需要主动同步到 new-api
   └─ 调用 new-api API
      POST /api/user
      {
        "quota": 2000  // 更新 new-api 用户 quota
      }

4️⃣ new-api 数据库
   └─ UPDATE users SET quota = 2000 WHERE id = 0;
```

### 场景：LetAiCode 用户调用 API

```
1️⃣ 用户请求
   GET /v1/chat/completions
   Authorization: Bearer sk-xxx

2️⃣ new-api 中间件 TokenAuth
   └─ 验证 token
   └─ 找到对应的 Token 对象
   └─ Token.user_id = 0 (letaicode_sync 用户)

3️⃣ relay 控制器
   └─ PreConsumeQuota(c, 100, relayInfo)
      ├─ 查询：SELECT quota FROM users WHERE id = 0
      ├─ 获得：quota = 2000
      ├─ 检查：2000 > 0 ✅ 且 2000 - 100 >= 0 ✅
      ├─ 预扣：UPDATE users SET quota = 1900 WHERE id = 0
      └─ 继续执行

4️⃣ 调用上游模型
   └─ 成功，消耗 80 tokens → 80 积分

5️⃣ 发送 Webhook 到 LetAiCode
   └─ eventId: xxx
   └─ remoteKeyId: 10 (Token ID)
   └─ creditCost: 80

6️⃣ LetAiCode 接收 Webhook
   └─ 查询：SELECT * FROM apiKeys WHERE remoteKeyId = 10
   └─ 找到：userId = "abc123"
   └─ 扣除：INSERT INTO creditTransactions (userId, amount, ...)
   └─ 结果：用户积分 2000 → 1920

7️⃣ 定期同步（可选）
   └─ LetAiCode 同步到 new-api
   └─ new-api users.quota 也更新为 1920
```

## ⚠️ 重要的概念转换

### 关键的映射关系

```
┌──────────────────────────────┬──────────────────────────────┐
│      LetAiCode 侧             │       new-api 侧             │
├──────────────────────────────┼──────────────────────────────┤
│ 用户 ID (UUID)                │ 用户 ID (整数)               │
│ "abc123-def456"             │ 0 (letaicode_sync)           │
├──────────────────────────────┼──────────────────────────────┤
│ 积分 (Credit)                │ 额度 (Quota)                 │
│ 交易记录：RECHARGE, DEDUCT   │ 单个值：扣除、返还            │
├──────────────────────────────┼──────────────────────────────┤
│ API Key (本地记录)            │ Token (本地记录)             │
│ remoteKeyId: 10              │ id: 10                       │
├──────────────────────────────┼──────────────────────────────┤
│ 使用记录                      │ 日志记录                      │
│ UsageRecord table            │ Log table                    │
└──────────────────────────────┴──────────────────────────────┘
```

### 数据流向

```
LetAiCode 积分系统（用户可见）
         ↓
【同步】 ↓
         ↓
new-api Quota 系统（系统内部）
         ↓
【Webhook 反馈】
         ↓
LetAiCode 使用记录
```

## 🔍 追踪一个具体例子

### 初始状态

```
LetAiCode 数据库：
├─ User: id="user-1", name="张三"
├─ ApiKey: id=10, userId="user-1", remoteKeyId=42, label="My GPT-4"
└─ CreditTransaction: userId="user-1", balance=1000

new-api 数据库：
├─ User: id=0, username="letaicode_sync", quota=1000
└─ Token: id=42, userId=0, name="letaicode-key-10", remain_quota=无限
```

### 用户调用 API

```
张三使用 sk-xxx (Token ID 42) 调用 API

【new-api 处理】
1. TokenAuth 验证
   ├─ Token 42 对应用户 ID: 0
   └─ 用户 ID 0 是 letaicode_sync（共享用户）

2. PreConsumeQuota
   ├─ 查询 users WHERE id = 0 的 quota = 1000 ✅
   ├─ 预扣：1000 - 100 = 900 ✅
   └─ 更新：UPDATE users SET quota = 900

3. 调用模型
   ├─ 成功
   └─ 实际消耗：80

4. 发送 Webhook
   ├─ remoteKeyId: 42
   ├─ creditCost: 80
   └─ POST /api/webhooks/events

【LetAiCode 处理】
5. 接收 Webhook
   ├─ 查询 ApiKey WHERE remoteKeyId = 42
   ├─ 找到 userId = "user-1"
   ├─ 查询用户当前积分: 1000

6. 记录使用
   ├─ 创建 UsageRecord
   ├─ 创建 CreditTransaction: -80
   └─ 新积分: 920

【最终状态】
LetAiCode: 张三的积分 1000 → 920 ✅
new-api: letaicode_sync 用户 quota 900 → (后续同步到 920)
```

## 💡 核心洞察

### new-api 为什么要有自己的 Quota？

```
理由 1：【权限检查】
├─ new-api 需要快速检查是否允许调用
├─ 直接查询本地的 users.quota 很快
└─ 不用每次都查询 LetAiCode 数据库

理由 2：【隔离性】
├─ new-api 作为基础设施应该独立
├─ 不应该依赖 LetAiCode 的实时可用性
├─ 如果 LetAiCode 宕机，new-api 仍然可以运作
└─ 但会受到本地 quota 的限制

理由 3：【成本控制】
├─ 防止恶意 token 被滥用
├─ 例如：某个 token 被泄露，可以限制其消耗
├─ new-api 管理员可以单独限制某个用户
└─ 保护系统资源

理由 4：【性能】
├─ 本地查询 quota：O(1) 快速
├─ 远程查询 LetAiCode：网络开销、可能失败
└─ 分布式系统中的常见做法：本地缓存关键数据
```

## 📋 总结：PreConsumeQuota 检查的三个层级

```
┌─────────────────────────────────────────────┐
│ 第 1 层：new-api 用户 Quota 检查            │
│ ├─ SELECT quota FROM users WHERE id = 0    │
│ ├─ 这是从 LetAiCode 同步来的                │
│ └─ 确保不超过总额度                        │
└─────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────┐
│ 第 2 层：Token 的 RemainQuota 检查          │
│ ├─ SELECT remain_quota FROM tokens WHERE id=42
│ ├─ 如果 Token 设置了上限，检查是否超出     │
│ └─ 这是对 Token 的额外限制                 │
└─────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────┐
│ 第 3 层：API 调用执行                       │
│ ├─ 如果前两层都通过，执行实际调用          │
│ └─ new-api 从本地 quota 中预扣              │
└─────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────┐
│ 第 4 层：Webhook 同步到 LetAiCode           │
│ ├─ 通知 LetAiCode 实际消耗情况             │
│ └─ LetAiCode 更新用户积分                  │
└─────────────────────────────────────────────┘
```

## ✅ 最终答案

### Q: PreConsumeQuota 检查的是什么？

**A: 检查的是 new-api 数据库中的 users.quota 字段**

### Q: 这个 quota 从哪来？

**A: 从 LetAiCode 同步过来的**

- LetAiCode 用户充值或消费时
- 需要同步到 new-api 的共享用户（letaicode_sync）的 quota
- 所以 new-api 的 quota 其实是"镜像"

### Q: 所以 new-api 其实不是"无限额度"？

**A: 半对半错**

- new-api 作为系统确实可以无限
- 但给 LetAiCode 连接的用户（letaicode_sync）的额度是受限的
- 这个限制来自 LetAiCode 的积分总额
- 这样实现了：**new-api 的无限性** + **LetAiCode 的积分控制**

### Q: 为什么要这样设计？

**A: 分离关注点**

```
LetAiCode: 管理用户积分（业务逻辑）
new-api:   提供 API 网关（基础设施）

虽然是两个独立系统，但通过：
├─ 数据同步（LetAiCode → new-api）
├─ Webhook 反馈（new-api → LetAiCode）
└─ 幂等性检查（防重复）

实现了紧密的积分控制
```

这就是为什么 PreConsumeQuota 能检查到 LetAiCode 的积分！ 🎯