# Webhook 实时积分扣除 - 部署检查清单

> **项目状态**：✅ 完成
> **开发日期**：2024-12-18
> **版本**：1.0.0

## 📋 部署前准备

### 第一部分：LetAiCode 后端配置

#### 1.1 环境变量配置 ✅
- [x] 编辑 `backend/.env` 文件
- [x] 添加 `WEBHOOK_SECRET` 配置项
  ```bash
  WEBHOOK_SECRET=your_32_char_secret_here_min_32_chars_change_in_production
  ```
- [x] 确保 `DATABASE_URL` 正确指向 MySQL 数据库
- [x] 确保 `NEW_API_BASE_URL` 和 `NEW_API_ADMIN_TOKEN` 正确配置

#### 1.2 数据库迁移 ✅
```bash
cd backend
npm install
npx prisma migrate dev --name add_webhook_log
```

**检查项**：
- [ ] 命令执行成功（无错误）
- [ ] 数据库中新增了 `webhook_logs` 表
- [ ] 表结构包含：`id`, `eventId`, `payload`, `status`, `errorMsg`, `processedAt`, `createdAt`
- [ ] `eventId` 字段有 UNIQUE 约束

#### 1.3 代码完整性检查 ✅

**文件存在性**：
- [x] `backend/src/services/webhook.service.ts` (210 行)
  - [x] `verifyWebhookSignature()` - HMAC-SHA256 签名验证
  - [x] `handleWebhookEvent()` - 核心事件处理
  - [x] `handleUsageEvent()` - 使用事件处理
  - [x] `cleanupOldWebhookLogs()` - 日志清理

- [x] `backend/src/controllers/webhook.controller.ts` (87 行)
  - [x] `handleWebhook()` - webhook 接收端点
  - [x] `healthCheck()` - 健康检查端点

- [x] `backend/src/routes/webhook.routes.ts` (16 行)
  - [x] `POST /events` - webhook 事件处理
  - [x] `GET /health` - 健康检查

- [x] `backend/prisma/schema.prisma`
  - [x] `WebhookLog` 模型已添加

- [x] `backend/src/routes/index.ts`
  - [x] webhook 路由已正确注册

### 第二部分：new-api 后端配置

#### 2.1 代码集成 ✅

**文件存在性**：
- [x] `service/webhook.go` (152 行)
  - [x] `SendWebhookUsageEvent()` - 发送使用事件
  - [x] `sendWebhookEventWithRetry()` - 带重试的发送
  - [x] `sendWebhookEvent()` - 单次发送
  - [x] `generateWebhookSignature()` - 签名生成

**集成点**：
- [x] `model/log.go` - `RecordConsumeLog()` 函数已集成 webhook 调用
  ```go
  if params.TokenId > 0 {
    totalTokens := params.PromptTokens + params.CompletionTokens
    service.SendWebhookUsageEvent(c, params.TokenId, params.ModelName,
      params.PromptTokens, params.CompletionTokens, totalTokens, params.Quota)
  }
  ```

#### 2.2 系统选项配置 ⚠️ 需要手动配置

在 new-api 管理后台，进入 **系统设置 → 系统选项**，创建以下选项：

**选项 1：webhook_url**
- 键：`webhook_url`
- 值：`https://your-letaicode-domain.com/api/webhooks/events`
  - 生产环境：使用实际的 LetAiCode 域名
  - 本地测试：`http://localhost:4000/api/webhooks/events`

**选项 2：webhook_secret**
- 键：`webhook_secret`
- 值：与 LetAiCode 的 `WEBHOOK_SECRET` **完全相同**
  - ⚠️ **重要**：两个密钥必须一致

```sql
-- 或者直接在数据库中插入（如果 UI 无法操作）
INSERT INTO options (key, value) VALUES ('webhook_url', 'https://your-domain/api/webhooks/events');
INSERT INTO options (key, value) VALUES ('webhook_secret', 'your-shared-secret-key');
```

#### 2.3 编译和部署

```bash
# 重新编译 new-api（包含新的 webhook.go）
go build -o new-api .

# 启动服务
./new-api
```

### 第三部分：集成验证

#### 3.1 基础连接测试

```bash
# 测试 LetAiCode webhook 端点可达性
curl -X GET http://localhost:4000/api/webhooks/health

# 预期响应：
# {
#   "success": true,
#   "message": "Webhook service is healthy",
#   "timestamp": "2024-12-18T12:00:00Z"
# }
```

#### 3.2 签名验证测试

生成测试 webhook 请求：

```bash
# 1. 生成 webhook payload
PAYLOAD='{"eventId":"test-001","eventType":"usage","timestamp":1702900800,"data":{"remoteKeyId":1,"model":"gpt-4","promptTokens":100,"completionTokens":50,"totalTokens":150,"creditCost":15}}'

# 2. 生成签名（假设 secret = "test-secret-key"）
SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "test-secret-key" -hex | cut -d' ' -f2)

# 3. 发送 webhook 请求
curl -X POST http://localhost:4000/api/webhooks/events \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Signature: $SIGNATURE" \
  -d "$PAYLOAD"

# 预期响应：
# {
#   "success": true,
#   "message": "Event processed successfully",
#   "eventId": "test-001"
# }
```

#### 3.3 数据库验证

查看 webhook 日志是否被正确记录：

```sql
-- 检查最近的 webhook 记录
SELECT eventId, status, errorMsg, createdAt
FROM webhook_logs
ORDER BY createdAt DESC
LIMIT 10;
```

### 第四部分：端到端集成测试

#### 4.1 创建测试用户和 API Key

1. 在 LetAiCode 创建测试用户账号
2. 为该用户充值积分（例如 1000 积分）
3. 创建 API Key 并记录其 ID（新增）

#### 4.2 模拟 API 调用

在 new-api 中，使用该 API Key 调用一个模型（例如 GPT-4）。

#### 4.3 验证数据流

**检查项**：

1. **LetAiCode 侧**：
   - [ ] `webhook_logs` 表中有新记录
   - [ ] 记录的 `status` 为 `processed`
   - [ ] `errorMsg` 为 null（成功的情况）

2. **LetAiCode 侧（业务数据）**：
   - [ ] `usage_records` 表中有新的使用记录
   - [ ] `credit_transactions` 表中有新的扣费记录
   - [ ] 用户的积分余额被正确扣除

3. **new-api 侧**：
   - [ ] 在日志中看到 `webhook sent successfully` 信息
   - [ ] 看不到 `webhook send failed` 或 retry 信息

### 第五部分：故障排查

#### 问题 1：webhook 无法送达

**症状**：LetAiCode 没有收到 webhook，`webhook_logs` 表为空

**排查步骤**：
```bash
# 1. 检查 new-api 日志
grep -i "webhook" new-api.log

# 2. 检查网络连接
curl -v http://localhost:4000/api/webhooks/health

# 3. 检查 webhook_url 配置
# 登录 new-api 管理后台查看系统选项
```

#### 问题 2：signature 验证失败

**症状**：返回 `Invalid webhook signature` 错误

**排查步骤**：
```bash
# 1. 验证两端 WEBHOOK_SECRET 是否相同
# LetAiCode: echo $WEBHOOK_SECRET
# new-api: 登录管理后台查看 webhook_secret

# 2. 检查是否有隐藏的空格
# 在 .env 和系统选项中确认
```

#### 问题 3：积分未扣除

**症状**：webhook 已处理，但 `credit_transactions` 表中没有扣费记录

**排查步骤**：
```bash
# 1. 检查 webhook_logs 表中的错误信息
SELECT * FROM webhook_logs WHERE status = 'failed' LIMIT 5;

# 2. 检查是否找到 API Key
# 确认 remoteKeyId 是否正确对应到 api_keys 表

# 3. 检查用户余额是否充足
SELECT balance FROM credit_transactions
WHERE userId = 'user-id'
ORDER BY createdAt DESC
LIMIT 1;
```

### 第六部分：监控和维护

#### 6.1 定期监控查询

```sql
-- 过去1小时的 webhook 处理统计
SELECT status, COUNT(*) as count, MAX(createdAt) as latest
FROM webhook_logs
WHERE createdAt > DATE_SUB(NOW(), INTERVAL 1 HOUR)
GROUP BY status;

-- 失败的 webhook 详情
SELECT eventId, errorMsg, createdAt
FROM webhook_logs
WHERE status = 'failed'
ORDER BY createdAt DESC
LIMIT 20;

-- 积分交易审计
SELECT u.email, ct.type, ct.amount, ct.balance, ct.createdAt
FROM credit_transactions ct
JOIN users u ON u.id = ct.userId
ORDER BY ct.createdAt DESC
LIMIT 100;
```

#### 6.2 清理旧 webhook 日志

```bash
# 可以定时运行此 SQL 清理 7 天前的已处理日志（可选）
DELETE FROM webhook_logs
WHERE status = 'processed'
AND createdAt < DATE_SUB(NOW(), INTERVAL 7 DAY);
```

### 第七部分：性能指标验证

部署后，验证以下性能指标：

| 指标 | 目标 | 验证方法 |
|------|------|---------|
| 积分扣除延迟 | < 100ms | 查看 webhook_logs 中的 createdAt 与 new-api 日志时间戳差异 |
| 幂等性验证速度 | < 1ms | 尝试发送相同 eventId 两次，检查是否快速返回 |
| webhook 成功率 | > 99% | 统计成功 vs 失败的 webhook 数量 |
| 数据一致性 | 100% | 验证 credit_transactions 与 usage_records 一一对应 |

### 第八部分：安全检查

部署前的安全检查清单：

- [ ] `WEBHOOK_SECRET` 已更改为生产环境密钥（至少 32 字符）
- [ ] `webhook_secret` 在 new-api 中已配置相同值
- [ ] 使用 HTTPS 加密传输（生产环境）
- [ ] 防火墙允许 new-api 到 LetAiCode 的连接
- [ ] 考虑配置 IP 白名单（可选）
- [ ] 考虑配置速率限制（可选）
- [ ] 定期审计 webhook_logs 表中的异常

### 第九部分：回退方案

如果 webhook 集成出现问题，可以快速回退：

1. **临时禁用 webhook**：
   ```sql
   UPDATE options SET value = '' WHERE key = 'webhook_url';
   ```

2. **恢复轮询同步**：
   - LetAiCode 仍保持 5 分钟轮询机制
   - 无需额外操作

3. **恢复时间**：预计 5-10 分钟内完全恢复到轮询模式

## ✅ 完成标记

所有部分完成后，在此标记：

```
□ 第一部分：LetAiCode 后端配置 - 完成
□ 第二部分：new-api 后端配置 - 完成
□ 第三部分：集成验证 - 完成
□ 第四部分：端到端集成测试 - 完成
□ 第五部分：故障排查 - 已审查
□ 第六部分：监控和维护 - 已审查
□ 第七部分：性能指标验证 - 完成
□ 第八部分：安全检查 - 完成
□ 第九部分：回退方案 - 已确认

部署日期：_______________
部署人员：_______________
验收人员：_______________
```

## 📞 支持和联系

如有问题，请：
1. 查看本清单的"故障排查"部分
2. 参考 `WEBHOOK_INTEGRATION_GUIDE.md` 获得详细说明
3. 查看相关的文档文件（见下表）

## 📚 相关文档

| 文档 | 用途 | 目标用户 |
|------|------|---------|
| `WEBHOOK_SETUP_QUICKSTART.md` | 5分钟快速开始 | 所有人 |
| `WEBHOOK_INTEGRATION_GUIDE.md` | 详细集成指南 | 开发人员 |
| `WEBHOOK_DEVELOPMENT_SUMMARY.md` | 技术开发总结 | 开发人员 |
| `SYSTEM_ARCHITECTURE_CLARIFICATION.md` | 架构理解 | 技术负责人 |
| `WEBHOOK_QUOTA_FLOW_EXPLANATION.md` | 流程详解 | 技术负责人 |
| `DEPLOYMENT_CHECKLIST.md` | 部署检查 | 运维人员 |

---

**祝部署顺利！** 🚀